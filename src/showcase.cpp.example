#include <TFT_eSPI.h>
#include <SPI.h>

TFT_eSPI tft = TFT_eSPI();

uint16_t HSVtoRGB(float h, float s, float v)
{
    s /= 255.0;
    v /= 255.0;

    float c = v * s;
    float x = c * (1 - abs(fmod(h / 60.0, 2) - 1));
    float m = v - c;

    float r, g, b;
    if (h >= 0 && h < 60)
    {
        r = c;
        g = x;
        b = 0;
    }
    else if (h >= 60 && h < 120)
    {
        r = x;
        g = c;
        b = 0;
    }
    else if (h >= 120 && h < 180)
    {
        r = 0;
        g = c;
        b = x;
    }
    else if (h >= 180 && h < 240)
    {
        r = 0;
        g = x;
        b = c;
    }
    else if (h >= 240 && h < 300)
    {
        r = x;
        g = 0;
        b = c;
    }
    else
    {
        r = c;
        g = 0;
        b = x;
    }

    return tft.color565((r + m) * 255, (g + m) * 255, (b + m) * 255);
}

void drawPolygon(int centerX, int centerY, int radius, int sides, float rotation, uint16_t color)
{
    for (int i = 0; i < sides; i++)
    {
        float angle1 = (2 * PI * i / sides) + rotation;
        float angle2 = (2 * PI * (i + 1) / sides) + rotation;

        int x1 = centerX + radius * cos(angle1);
        int y1 = centerY + radius * sin(angle1);
        int x2 = centerX + radius * cos(angle2);
        int y2 = centerY + radius * sin(angle2);

        tft.drawLine(x1, y1, x2, y2, color);
    }
}

void fontShowcase()
{
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.setTextFont(4);
    tft.setCursor(20, 10);
    tft.println("FONTS");

    // Show different font sizes
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextFont(1);
    tft.setCursor(5, 50);
    tft.println("Font 1: Small text for details");

    tft.setTextFont(2);
    tft.setCursor(5, 65);
    tft.println("Font 2: Medium text");

    tft.setTextFont(4);
    tft.setCursor(5, 85);
    tft.println("Font 4: Large");

    // Animated text color
    static float colorPhase = 0;
    colorPhase += 0.1;
    uint16_t animColor = tft.color565(
        128 + 127 * sin(colorPhase),
        128 + 127 * sin(colorPhase + 2),
        128 + 127 * sin(colorPhase + 4));

    tft.setTextColor(animColor, TFT_BLACK);
    tft.setTextFont(2);
    tft.setCursor(5, 115);
    tft.println("Animated colors!");
}

void animationShowcase()
{
    tft.setTextColor(TFT_YELLOW, TFT_BLACK);
    tft.setTextFont(4);
    tft.setCursor(10, 10);
    tft.println("ANIMATION");

    static float phase = 0;
    phase += 0.15;

    // Sine wave
    for (int x = 0; x < 240; x += 3)
    {
        int y = 70 + 25 * sin((x * 0.05) + phase);
        tft.drawPixel(x, y, TFT_GREEN);
        tft.drawPixel(x, y - 1, TFT_DARKGREEN);
    }

    // Orbiting circles
    float angle1 = phase;
    float angle2 = phase + PI;
    int centerX = 120, centerY = 100;
    int orbit = 30;

    int x1 = centerX + orbit * cos(angle1);
    int y1 = centerY + orbit * sin(angle1);
    int x2 = centerX + orbit * cos(angle2);
    int y2 = centerY + orbit * sin(angle2);

    tft.fillCircle(x1, y1, 8, TFT_CYAN);
    tft.fillCircle(x2, y2, 6, TFT_MAGENTA);

    // Clear trails
    if ((int)(phase * 10) % 3 == 0)
    {
        tft.fillRect(0, 45, 240, 90, TFT_BLACK);
    }
}

void colorShowcase()
{
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.setTextFont(4);
    tft.setCursor(30, 10);
    tft.println("COLORS");

    static int colorIndex = 0;
    colorIndex = (colorIndex + 1) % 360;

    // Rainbow gradient
    for (int x = 0; x < 240; x++)
    {
        float hue = (x + colorIndex) % 360;
        uint16_t color = HSVtoRGB(hue, 255, 255);
        tft.drawFastVLine(x, 45, 15, color);
    }

    // Color palette squares
    uint16_t colors[] = {TFT_RED, TFT_GREEN, TFT_BLUE, TFT_YELLOW,
                         TFT_CYAN, TFT_MAGENTA, TFT_WHITE, TFT_ORANGE};
    for (int i = 0; i < 8; i++)
    {
        int size = 15 + 5 * sin((colorIndex + i * 45) * PI / 180);
        tft.fillRect(10 + i * 28, 70, size, size, colors[i]);
    }

    // Moving gradient circle
    int circleX = 120 + 80 * cos(colorIndex * PI / 180);
    for (int r = 0; r < 15; r++)
    {
        uint8_t intensity = map(r, 0, 14, 255, 0);
        uint16_t color = tft.color565(intensity, intensity / 2, 255 - intensity);
        tft.drawCircle(circleX, 110, r, color);
    }
}

void shapeShowcase()
{
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setTextFont(4);
    tft.setCursor(30, 10);
    tft.println("SHAPES");

    static float rotation = 0;
    rotation += 0.05;

    // Rotating polygon
    drawPolygon(60, 70, 25, 6, rotation, TFT_CYAN);
    drawPolygon(120, 70, 20, 5, -rotation, TFT_YELLOW);
    drawPolygon(180, 70, 15, 8, rotation * 1.5, TFT_MAGENTA);

    // Morphing rectangle
    int w = 40 + 20 * sin(rotation * 2);
    int h = 20 + 15 * cos(rotation * 3);
    tft.drawRect(200, 100, w, h, TFT_RED);

    // Spiral
    for (int i = 0; i < 50; i++)
    {
        float angle = i * 0.5 + rotation;
        float radius = i * 0.8;
        int x = 60 + radius * cos(angle);
        int y = 110 + radius * sin(angle);
        tft.drawPixel(x, y, TFT_WHITE);
    }
}

void effectsShowcase()
{
    tft.setTextColor(TFT_PURPLE, TFT_BLACK);
    tft.setTextFont(4);
    tft.setCursor(20, 10);
    tft.println("EFFECTS");

    static int effectFrame = 0;
    effectFrame++;

    // Matrix-like effect
    for (int x = 0; x < 240; x += 15)
    {
        for (int y = 45; y < 135; y += 10)
        {
            if (random(100) < 5)
            {
                tft.setTextColor(TFT_GREEN, TFT_BLACK);
                tft.setTextFont(1);
                tft.setCursor(x, y);
                tft.print((char)(random(33, 127)));
            }
        }
    }

    // Fade effect
    if (effectFrame % 30 == 0)
    {
        for (int y = 45; y < 135; y++)
        {
            for (int x = 0; x < 240; x += 4)
            {
                uint16_t color = tft.readPixel(x, y);
                if (color != TFT_BLACK)
                {
                    // Fade to black
                    uint8_t r = (color >> 11) & 0x1F;
                    uint8_t g = (color >> 5) & 0x3F;
                    uint8_t b = color & 0x1F;

                    r = r > 1 ? r - 1 : 0;
                    g = g > 2 ? g - 2 : 0;
                    b = b > 1 ? b - 1 : 0;

                    tft.drawPixel(x, y, (r << 11) | (g << 5) | b);
                }
            }
        }
    }
}

void interactiveShowcase()
{
    tft.setTextColor(TFT_ORANGE, TFT_BLACK);
    tft.setTextFont(4);
    tft.setCursor(5, 10);
    tft.println("INTERACTIVE");

    // Show current time
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextFont(2);
    tft.setCursor(5, 45);
    tft.printf("Uptime: %lu ms", millis());

    // Memory usage (approximate)
    tft.setCursor(5, 65);
    tft.printf("Free heap: %d", ESP.getFreeHeap());

    // Interactive elements based on time
    int timeVal = (millis() / 100) % 100;

    // Progress bar
    tft.drawRect(5, 85, 200, 15, TFT_WHITE);
    tft.fillRect(6, 86, (timeVal * 198) / 100, 13, TFT_CYAN);

    // Responsive circle
    int circleSize = 5 + (timeVal / 5);
    tft.fillCircle(220, 92, circleSize, TFT_YELLOW);

    // Status indicator
    uint16_t statusColor = (timeVal < 30) ? TFT_GREEN : (timeVal < 70) ? TFT_YELLOW
                                                                       : TFT_RED;
    tft.fillCircle(10, 115, 8, statusColor);

    tft.setCursor(25, 110);
    tft.printf("Status: %s", (timeVal < 30) ? "OK" : (timeVal < 70) ? "WARN"
                                                                    : "ALERT");
}

void setup()
{
    Serial.begin(115200);

    tft.init();
    tft.setRotation(1);
    tft.fillScreen(TFT_BLACK);

    // Turn on backlight
    pinMode(4, OUTPUT);
    digitalWrite(4, HIGH);

    Serial.println("TFT_eSPI Showcase Starting!");
    Serial.println("Display capabilities demo...");
}

void loop()
{
    // Cycle through different demos
    static int demoMode = 0;
    static unsigned long lastModeSwitch = 0;

    if (millis() - lastModeSwitch > 4000)
    { // Switch every 4 seconds
        demoMode = (demoMode + 1) % 6;
        lastModeSwitch = millis();
        tft.fillScreen(TFT_BLACK);
    }

    switch (demoMode)
    {
    case 0:
        fontShowcase();
        break;
    case 1:
        animationShowcase();
        break;
    case 2:
        colorShowcase();
        break;
    case 3:
        shapeShowcase();
        break;
    case 4:
        effectsShowcase();
        break;
    case 5:
        interactiveShowcase();
        break;
    }
}