#include <TFT_eSPI.h>
#include <SPI.h>

TFT_eSPI tft = TFT_eSPI();

// Animation variables
float ballX = 20, ballY = 20;
float ballVelX = 2.5, ballVelY = 1.8;
int ballRadius = 8;

void bouncingBall()
{
    // Clear previous ball position
    static float lastX = ballX, lastY = ballY;
    tft.fillCircle(lastX, lastY, ballRadius + 1, TFT_BLACK);

    // Update position
    ballX += ballVelX;
    ballY += ballVelY;

    // Bounce off walls
    if (ballX <= ballRadius || ballX >= 240 - ballRadius)
    {
        ballVelX = -ballVelX;
        ballX = constrain(ballX, ballRadius, 240 - ballRadius);
    }
    if (ballY <= ballRadius || ballY >= 135 - ballRadius)
    {
        ballVelY = -ballVelY;
        ballY = constrain(ballY, ballRadius, 135 - ballRadius);
    }

    // Draw ball with gradient effect
    tft.fillCircle(ballX, ballY, ballRadius, TFT_CYAN);
    tft.fillCircle(ballX - 2, ballY - 2, ballRadius - 3, TFT_WHITE);

    // Store current position
    lastX = ballX;
    lastY = ballY;

    // Display speed info
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setTextFont(1);
    tft.setCursor(5, 5);
    tft.printf("Vel: %.1f,%.1f", ballVelX, ballVelY);
}

void rotatingSquare()
{
    static float angle = 0;
    static unsigned long lastTime = 0;

    if (millis() - lastTime > 50)
    {
        tft.fillScreen(TFT_BLACK);

        // Draw rotating square
        int centerX = 120, centerY = 67;
        int size = 30;

        // Calculate corner points
        float cos_a = cos(angle);
        float sin_a = sin(angle);

        int x1 = centerX + (-size * cos_a - -size * sin_a);
        int y1 = centerY + (-size * sin_a + -size * cos_a);
        int x2 = centerX + (size * cos_a - -size * sin_a);
        int y2 = centerY + (size * sin_a + -size * cos_a);
        int x3 = centerX + (size * cos_a - size * sin_a);
        int y3 = centerY + (size * sin_a + size * cos_a);
        int x4 = centerX + (-size * cos_a - size * sin_a);
        int y4 = centerY + (-size * sin_a + size * cos_a);

        // Draw lines
        tft.drawLine(x1, y1, x2, y2, TFT_RED);
        tft.drawLine(x2, y2, x3, y3, TFT_RED);
        tft.drawLine(x3, y3, x4, y4, TFT_RED);
        tft.drawLine(x4, y4, x1, y1, TFT_RED);

        angle += 0.1;
        lastTime = millis();
    }
}

void pulsingCircle()
{
    static float radius = 10;
    static float radiusVel = 0.5;
    static unsigned long lastTime = 0;

    if (millis() - lastTime > 30)
    {
        tft.fillScreen(TFT_BLACK);

        // Update radius
        radius += radiusVel;
        if (radius > 50 || radius < 5)
        {
            radiusVel = -radiusVel;
        }

        // Draw pulsing circle with color based on size
        uint16_t color = tft.color565(255 - radius * 4, radius * 4, 128);
        tft.fillCircle(120, 67, radius, color);

        lastTime = millis();
    }
}

void waveAnimation()
{
    static float phase = 0;
    static unsigned long lastTime = 0;

    if (millis() - lastTime > 50)
    {
        tft.fillScreen(TFT_BLACK);

        // Draw sine wave
        for (int x = 0; x < 240; x += 2)
        {
            int y = 67 + 30 * sin((x * 0.05) + phase);
            tft.drawPixel(x, y, TFT_GREEN);
            tft.drawPixel(x, y + 1, TFT_DARKGREEN);
        }

        // Draw cosine wave
        for (int x = 0; x < 240; x += 2)
        {
            int y = 67 + 20 * cos((x * 0.08) + phase);
            tft.drawPixel(x, y, TFT_BLUE);
        }

        phase += 0.2;
        lastTime = millis();
    }
}

void setup()
{
    Serial.begin(115200);

    tft.init();
    tft.setRotation(1);
    tft.fillScreen(TFT_BLACK);

    // Turn on backlight
    pinMode(4, OUTPUT);
    digitalWrite(4, HIGH);

    Serial.println("Animation Demo Starting...");
}

void loop()
{
    // Bouncing ball animation
    bouncingBall();
    delay(20);

    // Uncomment these for other animations
    // rotatingSquare();
    // pulsingCircle();
    // waveAnimation();
}
